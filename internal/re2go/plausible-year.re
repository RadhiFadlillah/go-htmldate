package re2go

/*!rules:re2c:base_template
re2c:eof              = 0;
re2c:yyfill:enable    = 0;
re2c:posix-captures   = 0;
re2c:case-insensitive = 0;

re2c:define:YYCTYPE     = byte;
re2c:define:YYPEEK      = "input[cursor]";
re2c:define:YYSKIP      = "cursor++";
re2c:define:YYBACKUP    = "marker = cursor";
re2c:define:YYRESTORE   = "cursor = marker";
re2c:define:YYLESSTHAN  = "limit <= cursor";
re2c:define:YYSTAGP     = "@@{tag} = cursor";
re2c:define:YYSTAGN     = "@@{tag} = -1";
re2c:define:YYSHIFTSTAG = "@@{tag} += @@{shift}";
*/

// PYTHON NAME: SELECT_YMD_PATTERN
// Original pattern: \D([0-3]?[0-9][/.-][01]?[0-9][/.-][0-9]{4})\D
func SelectYmdPatternSubmatchIndexes(input string) [][]int {
	var cursor, marker int
	input += string(rune(0)) // add terminating null
	limit := len(input) - 1  // limit points at the terminating null
	_ = marker

	// Variable for capturing parentheses (twice the number of groups).
	/*!maxnmatch:re2c*/
	yypmatch := make([]int, YYMAXNMATCH*2)
	var yynmatch int
	_ = yynmatch

	// Autogenerated tag variables used by the lexer to track tag values.
	/*!stags:re2c format = 'var @@ int; _ = @@\n'; */

	// Helper function
	copySlice := func(src []int) []int {
		indexes := make([]int, len(src))
		copy(indexes, src)
		return src
	}

	var allIndexes [][]int
	for { /*!use:re2c:base_template
		re2c:posix-captures = 1;

		ymd = [^0-9]([0-3]?[0-9][/.-][01]?[0-9][/.-][0-9]{4})[^0-9];

		{ymd} {
			allIndexes = append(allIndexes, copySlice(yypmatch))
			continue
		}

		* { continue }
		$ { return allIndexes }
		*/
	}
}

// PYTHON NAME: SLASHES_PATTERN
// Original pattern: \D([0-3]?[0-9]/[01]?[0-9]/[0129][0-9]|[0-3][0-9]\.[01][0-9]\.[0129][0-9])\D
func SlashesPatternSubmatchIndexes(input string) [][]int {
	var cursor, marker int
	input += string(rune(0)) // add terminating null
	limit := len(input) - 1  // limit points at the terminating null
	_ = marker

	// Variable for capturing parentheses (twice the number of groups).
	/*!maxnmatch:re2c*/
	yypmatch := make([]int, YYMAXNMATCH*2)
	var yynmatch int
	_ = yynmatch

	// Autogenerated tag variables used by the lexer to track tag values.
	/*!stags:re2c format = 'var @@ int; _ = @@\n'; */

	// Helper function
	copySlice := func(src []int) []int {
		indexes := make([]int, len(src))
		copy(indexes, src)
		return src
	}

	var allIndexes [][]int
	for { /*!use:re2c:base_template
		re2c:posix-captures = 1;

		slashes = [^0-9]([0-3]?[0-9][/][01]?[0-9][/][0129][0-9]|[0-3][0-9][.][01][0-9][.][0129][0-9])[^0-9];

		{slashes} {
			allIndexes = append(allIndexes, copySlice(yypmatch))
			continue
		}

		* { continue }
		$ { return allIndexes }
		*/
	}
}

// PYTHON NAME: MMYYYY_PATTERN
// Original pattern: \D([01]?[0-9][/.-][12][0-9]{3})\D
func MmYyyyPatternSubmatchIndexes(input string) [][]int {
	var cursor, marker int
	input += string(rune(0)) // add terminating null
	limit := len(input) - 1  // limit points at the terminating null
	_ = marker

	// Variable for capturing parentheses (twice the number of groups).
	/*!maxnmatch:re2c*/
	yypmatch := make([]int, YYMAXNMATCH*2)
	var yynmatch int
	_ = yynmatch

	// Autogenerated tag variables used by the lexer to track tag values.
	/*!stags:re2c format = 'var @@ int; _ = @@\n'; */

	// Helper function
	copySlice := func(src []int) []int {
		indexes := make([]int, len(src))
		copy(indexes, src)
		return src
	}

	var allIndexes [][]int
	for { /*!use:re2c:base_template
		re2c:posix-captures = 1;

		mmYyyy = [^0-9]([01]?[0-9][/.-][12][0-9]{3})[^0-9];

		{mmYyyy} {
			allIndexes = append(allIndexes, copySlice(yypmatch))
			continue
		}

		* { continue }
		$ { return allIndexes }
		*/
	}
}

// PYTHON NAME: SELECT_YMD_YEAR
// Given the following pattern:
// - year: 199[0-9]|20[0-3][0-9]
// Original pattern: (year)\D?$
func SelectYmdYearSubmatch(input string) []string {
	var cursor, marker int
	input += string(rune(0)) // add terminating null
	limit := len(input) - 1  // limit points at the terminating null
	_ = marker

	// Variable for capturing parentheses (twice the number of groups).
	/*!maxnmatch:re2c*/
	yypmatch := make([]int, YYMAXNMATCH*2)
	var yynmatch int
	_ = yynmatch

	// Autogenerated tag variables used by the lexer to track tag values.
	/*!stags:re2c format = 'var @@ int; _ = @@\n'; */

	// Helper function
	getSubmatch := func(input string, indexes []int) []string {
		submatches := make([]string, YYMAXNMATCH)
		for i := 0; i < YYMAXNMATCH; i++ {
			submatches[i] = input[indexes[2*i]:indexes[2*i+1]]
		}
		return submatches
	}

	for { /*!use:re2c:base_template
		re2c:posix-captures = 1;

		year = 199[0-9]|20[0-3][0-9];
		pattern = ({year})[^0-9]?;

		{pattern} {
			if yypmatch[1] == limit {
				return getSubmatch(input, yypmatch)
			}
			return nil
		}

		* { continue }
		$ { return nil }
		*/
	}
}

// PYTHON NAME: SLASHES_YEAR
// Original pattern: ([0-9]{2})$
func SlashesYearSubmatch(input string) []string {
	var cursor, marker int
	input += string(rune(0)) // add terminating null
	limit := len(input) - 1  // limit points at the terminating null
	_ = marker

	// Variable for capturing parentheses (twice the number of groups).
	/*!maxnmatch:re2c*/
	yypmatch := make([]int, YYMAXNMATCH*2)
	var yynmatch int
	_ = yynmatch

	// Autogenerated tag variables used by the lexer to track tag values.
	/*!stags:re2c format = 'var @@ int; _ = @@\n'; */

	// Helper function
	getSubmatch := func(input string, indexes []int) []string {
		submatches := make([]string, YYMAXNMATCH)
		for i := 0; i < YYMAXNMATCH; i++ {
			submatches[i] = input[indexes[2*i]:indexes[2*i+1]]
		}
		return submatches
	}

	for { /*!use:re2c:base_template
		re2c:posix-captures = 1;

		pattern = ([0-9]{2});

		{pattern} {
			if yypmatch[1] == limit {
				return getSubmatch(input, yypmatch)
			}
			continue
		}

		* { continue }
		$ { return nil }
		*/
	}
}

// PYTHON NAME: MMYYYY_YEAR
// Given the following pattern:
// - year: 199[0-9]|20[0-3][0-9]
// Original pattern: (year)\D?$
//
// It's the same as SELECT_YMD_YEAR, so we reuse it.
func MmYyyyYearSubmatch(input string) []string {
	return SelectYmdYearSubmatch(input)
}

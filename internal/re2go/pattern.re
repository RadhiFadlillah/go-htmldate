package re2go

/*!rules:re2c:base_template
re2c:eof              = 0;
re2c:yyfill:enable    = 0;
re2c:posix-captures   = 0;
re2c:case-insensitive = 0;

re2c:define:YYCTYPE     = byte;
re2c:define:YYPEEK      = "input[cursor]";
re2c:define:YYSKIP      = "cursor++";
re2c:define:YYBACKUP    = "marker = cursor";
re2c:define:YYRESTORE   = "cursor = marker";
re2c:define:YYLESSTHAN  = "limit <= cursor";
re2c:define:YYSTAGP     = "@@{tag} = cursor";
re2c:define:YYSTAGN     = "@@{tag} = -1";
re2c:define:YYSHIFTSTAG = "@@{tag} += @@{shift}";
*/

// TODO: check "août"
// PYTHON NAME: LONG_TEXT_PATTERN
// Given the following pattern:
//
// - day: [0-3]?[0-9]
// - year: 199[0-9]|20[0-3][0-9]
// - month: January?|February?|March|A[pv]ril|Ma[iy]|Jun[ei]|Jul[iy]|August|September|O[ck]tober|November|De[csz]ember|Jan|Feb|M[aä]r|Apr|Jun|Jul|Aug|Sep|O[ck]t|Nov|De[cz]|Januari|Februari|Maret|Mei|Agustus|Jänner|Feber|März|janvier|février|mars|juin|juillet|aout|septembre|octobre|novembre|décembre|Ocak|Şubat|Mart|Nisan|Mayıs|Haziran|Temmuz|Ağustos|Eylül|Ekim|Kasım|Aralık|Oca|Şub|Mar|Nis|Haz|Tem|Ağu|Eyl|Eki|Kas|Ara
//
// It's combined into two patterns:
//
// - MDY = ({rxMonth})[\t\n\f\r ]({rxDay})(!st|nd|rd|th)?,?[\t\n\f\r ]({rxYear})
// - DMY = ({rxDay})(!st|nd|rd|th|[.])?[\t\n\f\r ](!of[\t\n\f\r ])?({rxMonth})[,.]?[\t\n\f\r ]({rxYear})
func FindLongTextPattern(input string) (year, month, day string, ok bool) {
	var cursor, marker int
	input += string(rune(0)) // add terminating null
	limit := len(input) - 1  // limit points at the terminating null
	_ = marker

	// Variable for capturing parentheses (twice the number of groups).
	/*!maxnmatch:re2c*/
	yypmatch := make([]int, YYMAXNMATCH*2)
	var yynmatch int
	_ = yynmatch

	// Autogenerated tag variables used by the lexer to track tag values.
	/*!stags:re2c format = 'var @@ int; _ = @@\n'; */

	for { /*!use:re2c:base_template
		re2c:posix-captures   = 1;
		re2c:case-insensitive = 1;

		rxDay = [0-3]?[0-9];
		rxYear = 199[0-9]|20[0-3][0-9];
		rxMonth = January?|February?|March|A[pv]ril|Ma[iy]|Jun[ei]|Jul[iy]|August|September|O[ck]tober|November|De[csz]ember|Jan|Feb|M[aä]r|Apr|Jun|Jul|Aug|Sep|O[ck]t|Nov|De[cz]|Januari|Februari|Maret|Mei|Agustus|Jänner|Feber|März|janvier|février|mars|juin|juillet|aout|septembre|octobre|novembre|décembre|Ocak|Şubat|Mart|Nisan|Mayıs|Haziran|Temmuz|Ağustos|Eylül|Ekim|Kasım|Aralık|Oca|Şub|Mar|Nis|Haz|Tem|Ağu|Eyl|Eki|Kas|Ara;
		rxMDY = ({rxMonth})[\t\n\f\r ]({rxDay})(!st|nd|rd|th)?,?[\t\n\f\r ]({rxYear});
		rxDMY = ({rxDay})(!st|nd|rd|th|[.])?[\t\n\f\r ](!of[\t\n\f\r ])?({rxMonth})[,.]?[\t\n\f\r ]({rxYear});

		{rxMDY} {
			month = input[yypmatch[2]:yypmatch[3]]
			day = input[yypmatch[4]:yypmatch[5]]
			year = input[yypmatch[6]:yypmatch[7]]
			ok = true
			return
		}

		{rxDMY} {
			day = input[yypmatch[2]:yypmatch[3]]
			month = input[yypmatch[4]:yypmatch[5]]
			year = input[yypmatch[6]:yypmatch[7]]
			ok = true
			return
		}

		* { continue }
		$ { return }
		*/
	}
}

// PYTHON NAME: TEXT_DATE_PATTERN
// Original pattern: [.:,_/ -]|^\d+$
func MatchTextDatePattern(input string) bool {
	var cursor, marker int
	input += string(rune(0)) // add terminating null
	limit := len(input) - 1  // limit points at the terminating null
	_ = marker

	// Variable for capturing parentheses (twice the number of groups).
	/*!maxnmatch:re2c*/
	yypmatch := make([]int, YYMAXNMATCH*2)
	var yynmatch int
	_ = yynmatch

	// Autogenerated tag variables used by the lexer to track tag values.
	/*!stags:re2c format = 'var @@ int; _ = @@\n'; */

	for { /*!use:re2c:base_template
		re2c:posix-captures   = 1;

		[.:,_/ -] {
			// Handle [.:,_/ -]
			return true
		}

		[0-9]+ {
			// Handle ^\d+$
			if yypmatch[0] == 0 && yypmatch[1] == limit {
				return true
			}
			continue
		}

		* { continue }
		$ { return false }
		*/
	}
}

// PYTHON NAME: TEXT_PATTERNS
// Original pattern:
// - EN : (?i)(?:date[^0-9"]{0,20}|updated|published|on)(?:[ :])*?([0-9]{1,4})[./]([0-9]{1,2})[./]([0-9]{2,4})
// - DE : (?i)(?:Datum|Stand|Veröffentlicht am):? ?([0-9]{1,2})\.([0-9]{1,2})\.([0-9]{2,4})
// - TR1: (?i)(?:güncellen?me|yayı(?:m|n)lan?ma) *?(?:tarihi)? *?:? *?([0-9]{1,2})[./]([0-9]{1,2})[./]([0-9]{2,4})
// - TR2: (?i)([0-9]{1,2})[./]([0-9]{1,2})[./]([0-9]{2,4}) *?(?:'de|'da|'te|'ta|’de|’da|’te|’ta|tarihinde) *(?:güncellendi|yayı(?:m|n)landı)
func IdiosyncracyPatternSubmatch(input string) ([]string, int) {
	var cursor, marker int
	input += string(rune(0)) // add terminating null
	limit := len(input) - 1  // limit points at the terminating null
	_ = marker

	// Variable for capturing parentheses (twice the number of groups).
	/*!maxnmatch:re2c*/
	yypmatch := make([]int, YYMAXNMATCH*2)
	var yynmatch int
	_ = yynmatch

	// Autogenerated tag variables used by the lexer to track tag values.
	/*!stags:re2c format = 'var @@ int; _ = @@\n'; */

	// Helper function
	getSubmatch := func(input string, indexes []int) ([]string, int) {
		submatch := make([]string, YYMAXNMATCH)
		for i := 0; i < YYMAXNMATCH; i++ {
			submatch[i] = input[indexes[2*i]:indexes[2*i+1]]
		}
		return submatch, indexes[0]
	}

	for { /*!use:re2c:base_template
		re2c:posix-captures   = 1;
		re2c:case-insensitive = 1;

		en  = (!date[^0-9"]{0,20}|updated|published|on)(![ :])*?([0-9]{1,4})[./]([0-9]{1,2})[./]([0-9]{2,4});
		de  = (!Datum|Stand|Veröffentlicht[ ]am):?[ ]?([0-9]{1,2})[.]([0-9]{1,2})[.]([0-9]{2,4});
		tr1 = (!güncellen?me|yayı(!m|n)lan?ma)[ ]*?(!tarihi)?[ ]*?:?[ ]*?([0-9]{1,2})[./]([0-9]{1,2})[./]([0-9]{2,4});
		tr2 = ([0-9]{1,2})[./]([0-9]{1,2})[./]([0-9]{2,4})[ ]*?(!'de|'da|'te|'ta|’de|’da|’te|’ta|tarihinde)[ ]*(!güncellendi|yayı(!m|n)landı);

		{en} { return getSubmatch(input, yypmatch) }
		{de} { return getSubmatch(input, yypmatch) }
		{tr1} { return getSubmatch(input, yypmatch) }
		{tr2} { return getSubmatch(input, yypmatch) }

		* { continue }
		$ { return nil, -1 }
		*/
	}
}
